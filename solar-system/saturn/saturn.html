<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=400, user-scalable=no"/>
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script src="../../utils/three.js"></script>
  <script src="../../utils/orbitControls.js"></script>
  <script src="../../utils/resize.js"></script>
  <title>Saturn</title>
  <link rel="stylesheet" href="../style/style.css">
</head>

<body>
  <script>
    // 基础参数
    var _width = window.innerWidth
    var _height = window.innerHeight
    var fov = 50
    var aspect = _width / _height
    var near = 1
    var far = 2000
    var camera, scene, renderer
    var controls
    var ambitLight, light
    var saturnRing, saturn, ringA, ringB
    var saturnTexture, saturnMaterial, stoneTexture, stoneMaterial
    // 土星环A
    var saturnRingA = {
      minRadius: 35,
      maxRadius: 45,
      particles: 1000
    }
    // 土星环B
    var saturnRingB = {
      minRadius: 48,
      maxRadius: 55,
      particles: 1000,
    }
    // 木星贴图
    saturnTexture = THREE.ImageUtils.loadTexture('../image/saturn.jpg', {}, function() {
      renderer.render(scene, camera);
    })
    saturnMaterial = new THREE.MeshLambertMaterial({
      map: saturnTexture,
      ambient: 20
    });
    // 小行星贴图
    stoneTexture = THREE.ImageUtils.loadTexture('../image/planetoid.jpg', {}, function() {
      renderer.render(scene, camera);
    })
    stoneMaterial = new THREE.MeshLambertMaterial({
      map: stoneTexture
    })
    // 初始化函数
    function init() {
      camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
      camera.position.set(0, 0, 80)
      scene = new THREE.Scene()
      renderer = new THREE.WebGLRenderer({
        alpha: false,
        antialias: true
      })
      renderer.setSize(_width, _height)
      renderer.shadowMap.enabled = true
      document.body.appendChild(renderer.domElement)

      ambitLight = new THREE.AmbientLight(0xffffff, .2)
      light = new THREE.PointLight(0xffffff, 2, 200)
      light.position.set(80, 50, 80)
      scene.add(ambitLight)
      scene.add(light)
      saturn = new Saturn()
      scene.add(saturn.mesh)
      controls = new THREE.OrbitControls(camera, renderer.domElement)
      loop()
    }

    function loop() {
      saturn.star.rotation.y += 0.005
      saturn.ringA.rotation.y += 0.005
      saturn.ringB.rotation.y += 0.005
      saturn.updateRotate(saturn.ringA)
      saturn.updateRotate(saturn.ringB)
      renderer.render(scene, camera)
      requestAnimationFrame(loop)
    }

    var Saturn = function() {
      this.ringA = new THREE.Object3D()
      this.ringB = new THREE.Object3D()
      this.mesh = new THREE.Object3D()
      this.ringA.nParticles = 0
      var geometry = new THREE.SphereGeometry(30, 60, 60)
      this.star = new THREE.Mesh(geometry, saturnMaterial)
      this.mesh.add(this.star)
      this.mesh.add(this.ringA)
      this.mesh.add(this.ringB)
      this.mesh.rotation.x = Math.PI * 15 / 180
      this.mesh.rotation.z = Math.PI * 27 / 180
      this.saturnRing(saturnRingA, this.ringA)
      this.saturnRing(saturnRingB, this.ringB)
    }
    Saturn.prototype.saturnRing = function(objRing, ring) {
      var minRadius = objRing.minRadius
      var maxRadius = objRing.maxRadius
      var angle = Math.PI * 2 / objRing.particles
      for (var i = 0; i < objRing.particles; i++) {
        var stone = new Stone()
        var radius = minRadius + Math.random() * (maxRadius - minRadius)
        stone.mesh.position.set(radius * Math.cos(angle * i), .5 + Math.random() * -1, radius * Math.sin(angle * i))
        ring.add(stone.mesh)
      }
    }
    Saturn.prototype.updateRotate = function(ring) {
      for (var i = 0; i < ring.children.length; i++) {
        var m = ring.children[i]
        m.rotation.x += Math.random() * 4 * Math.PI / 180
        m.rotation.z += Math.random() * 3 * Math.PI / 180
      }
    }
    var Stone = function() {
      var random = getNumberInNormalDistribution(.125, .1)
      var s = .15
      var size = s + random * s
      var geom = new THREE.IcosahedronGeometry(random, 1)

      for (var i = 0, l = geom.vertices.length; i < l; i++) {
        geom.vertices[i].x += random * -0.25 + Math.random() * random * 0.5
        geom.vertices[i].y += random * -0.25 + Math.random() * random * 0.5
        //   geom.vertices[i].z += size * -0.25 + Math.random() * size * 0.5
      }

      this.mesh = new THREE.Mesh(geom, stoneMaterial)
      this.mesh.receiveShadow = true
      this.mesh.castShadow = true
      this.mesh.userData.po = this
    }

    function getNumberInNormalDistribution(mean, std_dev) {
      return mean + (randomNormalDistribution() * std_dev);
    }

    function randomNormalDistribution() {
      var u = 0.0,
        v = 0.0,
        w = 0.0,
        c = 0.0;
      do {
        //获得两个（-1,1）的独立随机变量
        u = Math.random() * 2 - 1.0;
        v = Math.random() * 2 - 1.0;
        w = u * u + v * v;
      } while (w == 0.0 || w >= 1.0)
      //这里就是 Box-Muller转换
      c = Math.sqrt((-2 * Math.log(w)) / w);
      //返回2个标准正态分布的随机数，封装进一个数组返回
      //当然，因为这个函数运行较快，也可以扔掉一个
      //return [u*c,v*c];
      return u * c;
    }
    init()
  </script>
</body>

</html>
